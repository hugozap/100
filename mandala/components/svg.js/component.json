{
  "name": "svg.js",
  "repo": "wout/svg.js",
  "description": "A lightweight library for manipulating and animating SVG",
  "version": "2.0.1",
  "keywords": [
    "svg"
  ],
  "author": {
    "name": "Wout Fierens",
    "email": "wout@impinc.co.uk"
  },
  "main": "dist/svg.js",
  "scripts": [
    "dist/svg.js"
  ],
  "license": "MIT",
  "gitHead": "d0e24c5a8d20167c03ec9b8873d1c459001b9dac",
  "readme": "# SVG.js\n\nA lightweight library for manipulating and animating SVG.\n\nSvg.js has no dependencies and aims to be as small as possible.\n\nSvg.js is licensed under the terms of the MIT License.\n\nSee [svgjs.com](http://svgjs.com) for an introduction, [documentation](http://documentup.com/wout/SVG.js) and [some action](http://svgjs.com/test).\n\n## Usage\n\n### Create an SVG document\n\nUse the `SVG()` function to create an SVG document within a given html element:\n\n```javascript\nvar draw = SVG('drawing').size(300, 300)\nvar rect = draw.rect(100, 100).attr({ fill: '#f06' })\n```\nThe first argument can either be an id of the element or the selected element itself.\nThis will generate the following output:\n\n```html\n<div id=\"drawing\">\n\t<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"300\" height=\"300\">\n\t\t<rect width=\"100\" height=\"100\" fill=\"#f06\"></rect>\n\t</svg>\n</div>\n```\n\nBy default the svg drawing follows the dimensions of its parent, in this case `#drawing`:\n\n```javascript\nvar draw = SVG('drawing').size('100%', '100%')\n```\n\n### Checking for SVG support\n\nBy default this library assumes the client's browser supports SVG. You can test support as follows:\n\n```javascript\nif (SVG.supported) {\n  var draw = SVG('drawing')\n  var rect = draw.rect(100, 100)\n} else {\n  alert('SVG not supported')\n}\n```\n\n\n### SVG document\nSvg.js also works outside of the HTML DOM, inside an SVG document for example:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<svg id=\"drawing\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" >\n  <script type=\"text/javascript\" xlink:href=\"svg.min.js\"></script>\n  <script type=\"text/javascript\">\n    <![CDATA[\n      var draw = SVG('drawing')\n      draw.rect(100,100).animate().fill('#f03').move(100,100)\n    ]]>\n  </script>\n</svg>\n```\n\n### Sub-pixel offset fix\nCall the `spof()` method to fix sub-pixel offset:\n\n```javascript\nvar draw = SVG('drawing').spof()\n```\n\nTo enable automatic sub-pixel offset correction when the window is resized:\n\n```javascript\nSVG.on(window, 'resize', function() { draw.spof() })\n```\n\n## Parent elements\n\n### Main svg document\nThe main SVG.js initializer function creates a root svg node in the given element and returns an instance of `SVG.Doc`:\n\n```javascript\nvar draw = SVG('drawing')\n```\n\n__`returns`: `SVG.Doc`__\n\n_Javascript inheritance stack: `SVG.Doc` < `SVG.Container` < `SVG.Parent`_\n\n### Nested svg\nWith this feature you can nest svg documents within each other. Nested svg documents have exactly the same features as the main, top-level svg document:\n\n```javascript\nvar nested = draw.nested()\n\nvar rect = nested.rect(200, 200)\n```\n\n__`returns`: `SVG.Nested`__\n\n_Javascript inheritance stack: `SVG.Nested` < `SVG.Container` < `SVG.Parent`_\n\n### Groups\nGrouping elements is useful if you want to transform a set of elements as if it were one. All element within a group maintain their position relative to the group they belong to. A group has all the same element methods as the root svg document:\n\n```javascript\nvar group = draw.group()\ngroup.path('M10,20L30,40')\n```\n\nExisting elements from the svg document can also be added to a group:\n\n```javascript\ngroup.add(rect)\n```\n\n__Note:__ Groups do not have a geometry of their own, it's inherited from their content. Therefore groups do not listen to `x`, `y`, `width` and `height` attributes. If that is what you are looking for, use a `nested()` svg instead.\n\n__`returns`: `SVG.G`__\n\n_Javascript inheritance stack: `SVG.G` < `SVG.Container` < `SVG.Parent`_\n\n### Hyperlink\nA hyperlink or `<a>` tag creates a container that enables a link on all children:\n\n```javascript\nvar link = draw.link('http://svgjs.com')\nvar rect = link.rect(100, 100)\n```\n\nThe link url can be updated with the `to()` method:\n\n```javascript\nlink.to('http://apple.com')\n```\n\nFurthermore, the link element has a `show()` method to create the `xlink:show` attribute:\n\n```javascript\nlink.show('replace')\n```\n\nAnd the `target()` method to create the `target` attribute:\n\n```javascript\nlink.target('_blank')\n```\n\nElements can also be linked the other way around with the `linkTo()` method:\n\n```javascript\nrect.linkTo('http://svgjs.com')\n```\n\nAlternatively a block can be passed instead of a url for more options on the link element:\n\n```javascript\nrect.linkTo(function(link) {\n  link.to('http://svgjs.com').target('_blank')\n})\n```\n\n__`returns`: `SVG.A`__\n\n_Javascript inheritance stack: `SVG.A` < `SVG.Container` < `SVG.Parent`_\n\n### Defs\nThe `<defs>` element is a container element for referenced elements. Elements that are descendants of a ‘defs’ are not rendered directly. The `<defs>` node lives in the main `<svg>` document and can be accessed with the `defs()` method:\n\n```javascript\nvar defs = draw.defs()\n```\n\nThe defs are also available on any other element through the `doc()` method:\n\n```javascript\nvar defs = rect.doc().defs()\n```\n\nThe defs node works exactly the same as groups.\n\n__`returns`: `SVG.Defs`__\n\n_Javascript inheritance stack: `SVG.Defs` < `SVG.Container` < `SVG.Parent`_\n\n## Rect\nRects have two arguments, their `width` and `height`:\n\n```javascript\nvar rect = draw.rect(100, 100)\n```\n\n__`returns`: `SVG.Rect`__\n\n_Javascript inheritance stack: `SVG.Rect` < `SVG.Shape` < `SVG.Element`_\n\n### radius()\nRects can also have rounded corners:\n\n```javascript\nrect.radius(10)\n```\n\nThis will set the `rx` and `ry` attributes to `10`. To set `rx` and `ry` individually:\n\n```javascript\nrect.radius(10, 20)\n```\n\n__`returns`: `itself`__\n\n## Circle\nThe only argument necessary for a circle is the diameter:\n\n```javascript\nvar circle = draw.circle(100)\n```\n\n__`returns`: `SVG.Circle`__\n\n_Javascript inheritance stack: `SVG.Circle` < `SVG.Shape` < `SVG.Element`_\n\n### radius()\nCircles can also be redefined by their radius:\n\n```javascript\nrect.radius(75)\n```\n\n__`returns`: `itself`__\n\n## Ellipse\nEllipses, like rects, have two arguments, their `width` and `height`:\n\n```javascript\nvar ellipse = draw.ellipse(200, 100)\n```\n\n__`returns`: `SVG.Ellipse`__\n\n_Javascript inheritance stack: `SVG.Ellipse` < `SVG.Shape` < `SVG.Element`_\n\n### radius()\nEllipses can also be redefined by their radii:\n\n```javascript\nrect.radius(75, 50)\n```\n\n__`returns`: `itself`__\n\n## Line\nCreate a line from point A to point B:\n\n```javascript\nvar line = draw.line(0, 0, 100, 150).stroke({ width: 1 })\n```\n\nCreating a line element can be done in four ways. Look at the `plot()` method to see all the possiblilities.\n\n__`returns`: `SVG.Line`__\n\n_Javascript inheritance stack: `SVG.Line` < `SVG.Shape` < `SVG.Element`_\n\n### plot()\nUpdating a line is done with the `plot()` method:\n\n```javascript\nline.plot(50, 30, 100, 150)\n```\n\nAlternatively it also accepts a point string:\n\n```javascript\nline.plot('0,0 100,150')\n```\n\nOr a point array:\n\n```javascript\nline.plot([[0, 0], [100, 150]])\n```\n\nOr an instance of `SVG.PointArray`:\n\n```javascript\nvar array = new SVG.PointArray([[0, 0], [100, 150]])\nline.plot(array)\n```\n\n__`returns`: `itself`__\n\n### array()\nReferences the `SVG.PointArray` instance. This method is rather intended for internal use:\n\n```javascript\npolyline.array()\n```\n\n__`returns`: `SVG.PointArray`__\n\n\n## Polyline\nThe polyline element defines a set of connected straight line segments. Typically, polyline elements define open shapes:\n\n```javascript\n// polyline('x,y x,y x,y')\nvar polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 })\n```\n\nPolyline strings consist of a list of points separated by spaces: `x,y x,y x,y`.\n\nAs an alternative an array of points will work as well:\n\n```javascript\n// polyline([[x,y], [x,y], [x,y]])\nvar polyline = draw.polyline([[0,0], [100,50], [50,100]]).fill('none').stroke({ width: 1 })\n```\n\n__`returns`: `SVG.Polyline`__\n\n_Javascript inheritance stack: `SVG.Polyline` < `SVG.Shape` < `SVG.Element`_\n\n### plot()\nPolylines can be updated using the `plot()` method:\n\n```javascript\npolyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])\n```\n\nThe `plot()` method can also be animated:\n\n```javascript\npolyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])\n```\n\n__`returns`: `itself`__\n\n### array()\nReferences the `SVG.PointArray` instance. This method is rather intended for internal use:\n\n```javascript\npolyline.array()\n```\n\n__`returns`: `SVG.PointArray`__\n\n## Polygon\nThe polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments:\n\n```javascript\n// polygon('x,y x,y x,y')\nvar polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 })\n```\n\nPolygon strings are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically.\n\n__`returns`: `SVG.Polygon`__\n\n_Javascript inheritance stack: `SVG.Polygon` < `SVG.Shape` < `SVG.Element`_\n\n### plot()\nLike polylines, polygons can be updated using the `plot()` method:\n\n```javascript\npolygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])\n```\n\nThe `plot()` method can also be animated:\n\n```javascript\npolygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])\n```\n\n__`returns`: `itself`__\n\n### array()\nReferences the `SVG.PointArray` instance. This method is rather intended for internal use:\n\n```javascript\npolygon.array()\n```\n\n__`returns`: `SVG.PointArray`__\n\n## Path\nThe path string is similar to the polygon string but much more complex in order to support curves:\n\n```javascript\ndraw.path('M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')\n```\n\n__`returns`: `SVG.Path`__\n\n_Javascript inheritance stack: `SVG.Path` < `SVG.Shape` < `SVG.Element`_\n\nFor more details on path data strings, please refer to the SVG documentation:\nhttp://www.w3.org/TR/SVG/paths.html#PathData\n\n### plot()\nPaths can be updated using the `plot()` method:\n\n```javascript\npath.plot('M100,200L300,400')\n```\n\n__`returns`: `itself`__\n\n### array()\nReferences the `SVG.PathArray` instance. This method is rather intended for internal use:\n\n```javascript\npath.array()\n```\n\n__`returns`: `SVG.PathArray`__\n\n## Image\nCreating images is as you might expect:\n\n```javascript\nvar image = draw.image('/path/to/image.jpg')\n```\n\nIf you know the size of the image, those parameters can be passed as the second and third arguments:\n\n```javascript\nvar image = draw.image('/path/to/image.jpg', 200, 300)\n```\n\n__`returns`: `SVG.Image`__\n\n_Javascript inheritance stack: `SVG.Image` < `SVG.Shape` < `SVG.Element`_\n\n### load()\nLoading another image can be done with the `load()` method:\n\n```javascript\nimage.load('/path/to/another/image.jpg')\n```\n\n__`returns`: `itself`__\n\n### loaded()\nIf you don't know the size of the image, obviously you will have to wait for the image to be `loaded`:\n\n```javascript\nvar image = draw.image('/path/to/image.jpg').loaded(function(loader) {\n  this.size(loader.width, loader.height)\n})\n```\n\nThe returned `loader` object as first the argument of the loaded method contains four values:\n- `width`\n- `height`\n- `ratio` (width / height)\n- `url`\n\n__`returns`: `itself`__\n\n\n## Text\nUnlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements.\n\nThe first and easiest method is to provide a string of text, split by newlines:\n\n```javascript\nvar text = draw.text(\"Lorem ipsum dolor sit amet consectetur.\\nCras sodales imperdiet auctor.\")\n```\n\nThis will automatically create a block of text and insert newlines where necessary.\n\nThe second method will give you much more control but requires a bit more code:\n\n```javascript\nvar text = draw.text(function(add) {\n  add.tspan('Lorem ipsum dolor sit amet ').newLine()\n  add.tspan('consectetur').fill('#f06')\n  add.tspan('.')\n  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)\n  add.tspan('Nunc ultrices lectus at erat').newLine()\n  add.tspan('dictum pharetra elementum ante').newLine()\n})\n```\n\nIf you want to go the other way and don't want to add tspans at all, just one line of text, you can use the `plain()` method instead:\n\n```javascript\nvar text = draw.plain('Lorem ipsum dolor sit amet consectetur.')\n```\n\nThis is a shortcut to the `plain` method on the `SVG.Text` instance which doesn't render newlines at all.\n\n_Javascript inheritance stack: `SVG.Text` < `SVG.Shape` < `SVG.Element`_\n\n__`returns`: `SVG.Text`__\n\n### text()\nChanging text afterwards is also possible with the `text()` method:\n\n```javascript\ntext.text('Brilliant!')\n```\n\n__`returns`: `itself`__\n\nTo get the raw text content:\n\n```javascript\ntext.text()\n```\n\n__`returns`: `string`__\n\n### tspan()\nJust adding one tspan is also possible:\n\n```javascript\ntext.tspan(' on a train...').fill('#f06')\n```\n\n__`returns`: `SVG.Tspan`__\n\n### plain()\nIf the content of the element doesn't need any stying or multiple lines, it might be sufficient to just add some plain text:\n\n```javascript\ntext.plain('I do not have any expectations.')\n```\n\n__`returns`: `itself`__\n\n### font()\nThe sugar.js module provides some syntax sugar specifically for this element type:\n\n```javascript\ntext.font({\n  family:   'Helvetica'\n, size:     144\n, anchor:   'middle'\n, leading:  '1.5em'\n})\n```\n\n__`returns`: `itself`__\n\n### leading()\nAs opposed to html, where leading is defined by `line-height`, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by `<tspan>` nodes with a `dy` attribute defining the line height and a `x` value resetting the line to the `x` position of the parent text element. But you can also have many nodes in one line defining a different `y`, `dy`, `x` or even `dx` value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it's height is. The `leading()` method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html:\n\n```javascript\nvar text = draw.text(\"Lorem ipsum dolor sit amet consectetur.\\nCras sodales imperdiet auctor.\")\ntext.leading(1.3)\n```\n\nThis will render a text element with a tspan element for each line, with a `dy` value of `130%` of the font size.\n\nNote that the `leading()` method assumes that every first level tspan in a text node represents a new line. Using `leading()` on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambeled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the `newLine()` method on every first level tspan added in the block passed as argument to the text element.\n\n__`returns`: `itself`__\n\n### build()\nThe `build()` can be used to enable / disable build mode. With build mode disabled, the `plain()` and `tspan()` methods will first call the `clear()` bethod before adding the new content. So when build mode is enabled, `plain()` and `tspan()` will append the new content to the existing content. When passing a block to the `text()` method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually:\n\n\n```javascript\nvar text = draw.text('This is just the start, ')\n\ntext.build(true)  // enables build mode\n\nvar tspan = text.tspan('something pink in the middle ').fill('#00ff97')\ntext.plain('and again boring at the end.')\n\ntext.build(false) // disables build mode\n\ntspan.animate('2s').fill('#f06')\n```\n\n__`returns`: `itself`__\n\n### rebuild()\nThis is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver `font-size` and `x` attributes or the `leading()` of the text element are modified. This method also acts a setter to enable or disable rebuilding:\n\n```javascript\ntext.rebuild(false) //-> disables rebuilding\ntext.rebuild(true)  //-> enables rebuilding and instantaneously rebuilds the text element\n```\n\n__`returns`: `itself`__\n\n### clear()\nClear all the contents of the called text element:\n\n```javascript\ntext.clear()\n```\n\n__`returns`: `itself`__\n\n### length()\nGets the total computed text length of all tspans together:\n\n```javascript\ntext.length()\n```\n\n__`returns`: `number`__\n\n\n### lines()\nAll first level tspans can be referenced with the `lines()` method:\n\n```javascript\ntext.lines()\n```\n\nThis will return an intance of `SVG.Set` including all `tspan` elements.\n\n__`returns`: `SVG.Set`__\n\n### events\nThe text element has one event. It is fired every time the `rebuild()` method is called:\n\n```javascript\ntext.on('rebuild', function() {\n  // whatever you need to do after rebuilding\n})\n```\n\n## Tspan\nThe tspan elements are only available inside text elements or inside other tspan elements. In SVG.js they have a class of their own:\n\n_Javascript inheritance stack: `SVG.Tspan` < `SVG.Shape` < `SVG.Element`_\n\n### text()\nUpdate the content of the tspan. This can be done by either passing a string:\n\n\n```javascript\ntspan.text('Just a string.')\n```\n\nWhich will basicly call the `plain()` method.\n\nOr by passing a block to add more specific content inside the called tspan:\n\n```javascript\ntspan.text(function(add) {\n  add.plain('Just plain text.')\n  add.tspan('Fancy text wrapped in a tspan.').fill('#f06')\n  add.tspan(function(addMore) {\n    addMore.tspan('And you can doo deeper and deeper...')\n  })\n})\n```\n\n__`returns`: `itself`__\n\n### tspan()\nAdd a nested tspan:\n\n```javascript\ntspan.tspan('I am a child of my parent').fill('#f06')\n```\n\n__`returns`: `SVG.Tspan`__\n\n### plain()\nJust adds some plain text:\n\n```javascript\ntspan.plain('I do not have any expectations.')\n```\n\n__`returns`: `itself`__\n\n### dx()\nDefine the dynamic `x` value of the element, much like a html element with `position:relative` and `left` defined:\n\n```javascript\ntspan.dx(30)\n```\n\n__`returns`: `itself`__\n\n### dy()\nDefine the dynamic `y` value of the element, much like a html element with `position:relative` and `top` defined:\n\n```javascript\ntspan.dy(30)\n```\n\n__`returns`: `itself`__\n\n### newLine()\nThe `newLine()` is a convenience method for adding a new line with a `dy` attribute using the current \"leading\":\n\n```javascript\nvar text = draw.text(function(add) {\n  add.tspan('Lorem ipsum dolor sit amet ').newLine()\n  add.tspan('consectetur').fill('#f06')\n  add.tspan('.')\n  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)\n  add.tspan('Nunc ultrices lectus at erat').newLine()\n  add.tspan('dictum pharetra elementum ante').newLine()\n})\n```\n\n__`returns`: `itself`__\n\n### clear()\nClear all the contents of the called tspan element:\n\n```javascript\ntspan.clear()\n```\n\n__`returns`: `itself`__\n\n### length()\nGets the total computed text length:\n\n```javascript\ntspan.length()\n```\n\n__`returns`: `number`__\n\n## TextPath\nA nice feature in svg is the ability to run text along a path:\n\n```javascript\nvar text = draw.text(function(add) {\n  add.tspan('We go ')\n  add.tspan('up').fill('#f09').dy(-40)\n  add.tspan(', then we go down, then up again').dy(40)\n})\ntext\n  .path('M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')\n  .font({ size: 42.5, family: 'Verdana' })\n```\n\nWhen calling the `path()` method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a `plot()` method to update the path:\n\n```javascript\ntext.plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')\n```\n\nAttributes specific to the `<textPath>` element can be applied to the textPath instance itself:\n\n```javascript\ntext.textPath().attr('startOffset', 0.5)\n```\n\nAnd they can be animated as well of course:\n\n```javascript\ntext.textPath().animate(3000).attr('startOffset', 0.8)\n```\n\n__`returns`: `SVG.TextPath`__\n\n_Javascript inheritance stack: `SVG.TextPath` < `SVG.Element`_\n\n### textPath()\nReferencing the textPath node directly:\n\n```javascript\nvar textPath = text.textPath()\n```\n\n__`returns`: `SVG.TextPath`__\n\n### track()\nReferencing the linked path element directly:\n\n```javascript\nvar path = text.track()\n```\n\n__`returns`: `SVG.Path`__\n\n## Use\nThe use element simply emulates another existing element. Any changes on the master element will be reflected on all the `use` instances. The usage of `use()` is very straightforward:\n\n```javascript\nvar rect = draw.rect(100, 100).fill('#f09')\nvar use  = draw.use(rect).move(200, 200)\n```\n\nIn the case of the example above two rects will appear on the svg drawing, the original and the `use` instance. In some cases you might want to hide the original element. the best way to do this is to create the original element in the defs node:\n\n```javascript\nvar rect = draw.defs().rect(100, 100).fill('#f09')\nvar use  = draw.use(rect).move(200, 200)\n```\n\nIn this way the rect element acts as a library element. You can edit it but it won't be rendered.\n\nAnother way is to point an external SVG file, just specified the element `id` and path to file.\n\n```javascript\nvar use  = draw.use('elementId', 'path/to/file.svg')\n```\n\nThis way is usefull when you have complex images already created.\nNote that, for external images (outside your domain) it may be necessary to load the file with XHR.\n\n__`returns`: `SVG.Use`__\n\n_Javascript inheritance stack: `SVG.Use` < `SVG.Shape` < `SVG.Element`_\n\n## Symbol\nNot unlike the `group` element, the `symbol` element is a container element. The only difference between symbols and groups is that symbols are not rendered. Therefore a `symbol` element is ideal in combination with the `use` element:\n\n```javascript\nvar symbol = draw.symbol()\nsymbol.rect(100, 100).fill('#f09')\n\nvar use  = draw.use(symbol).move(200, 200)\n```\n\n__`returns`: `SVG.Bare`__\n\n_Javascript inheritance stack: `SVG.Bare` < `SVG.Element` [with a shallow inheritance from `SVG.Parent`]_\n\n## Bare\nFor all SVG elements that are not described by SVG.js, the `SVG.Bare` class comes in handy. This class inherits directly from `SVG.Element` and makes it possible to add custom methods in a separate namespace without polluting the main `SVG.Element` namespace. Consider it your personal playground.\n\n### element()\nThe `SVG.Bare` class can be instantiated with the `element()` method on any parent element:\n\n```javascript\nvar element = draw.element('title')\n```\nThe string value passed as the first argument is the node name that should be generated.\n\nAdditionally any existing class name can be passed as the second argument to define from which class the element should inherit:\n\n```javascript\nvar element = draw.element('symbol', SVG.Parent)\n```\n\nThis gives you as the user a lot of power. But remember, with great power comes great responsibility.\n\n__`returns`: `SVG.Bare`__\n\n### words()\nThe `SVG.Bare` instance carries an additional method to add plain text:\n\n```javascript\nvar element = draw.element('title').words('This is a title.')\n//-> <title>This is a title.</title>\n```\n\n__`returns`: `itself`__\n\n## Referencing elements\n\n### By id\nIf you want to get an element created by SVG.js by its id, you can use the `SVG.get()` method:\n\n```javascript\nvar element = SVG.get('my_element')\n\nelement.fill('#f06')\n```\n\n### Using CSS selectors\nThere are two ways to select elements using CSS selectors.\n\nThe first is to search globally. This will search in all svg elements in a document and return them in an instance of `SVG.Set`:\n\n```javascript\nvar elements = SVG.select('rect.my-class').fill('#f06')\n```\n\nThe second is to search within a parent element:\n\n```javascript\nvar elements = group.select('rect.my-class').fill('#f06')\n```\n\n### Using jQuery or Zepto\nAnother way is to use [jQuery](http://jquery.com/) or [Zepto](http://zeptojs.com/). Here is an example:\n\n```javascript\n/* add elements */\nvar draw   = SVG('drawing')\nvar group  = draw.group().addClass('my-group')\nvar rect   = group.rect(100,100).addClass('my-element')\nvar circle = group.circle(100).addClass('my-element').move(100, 100)\n\n/* get elements in group */\nvar elements = $('#drawing g.my-group .my-element').each(function() {\n  this.instance.animate().fill('#f09')\n})\n```\n\n## Circular reference\nEvery element instance within SVG.js has a reference to the actual `node`:\n\n### node\n```javascript\nelement.node\n```\n__`returns`: `node`__\n\n### native()\nThe same can be achieved with the `native()` method:\n```javascript\nelement.native()\n```\n__`returns`: `node`__\n\n\n### instance\nSimilar, the node carries a reference to the SVG.js `instance`:\n\n```javascript\nnode.instance\n```\n__`returns`: `element`__\n\n## Parent reference\nEvery element has a reference to its parent with the `parent()` method:\n\n### parent()\n\n```javascript\nelement.parent()\n```\n\n__`returns`: `element`__\n\nEven the main svg document:\n\n```javascript\nvar draw = SVG('drawing')\n\ndraw.parent() //-> returns the wrappig html element with id 'drawing'\n```\n\n__`returns`: `HTMLNode`__\n\n\n### doc()\nFor more specific parent filtering the `doc()` method can be used:\n\n```javascript\nvar draw = SVG('drawing')\nvar rect = draw.rect(100, 100)\n\nrect.doc() //-> returns draw\n```\n\nAlternatively a class can be passed as the first argument:\n\n```javascript\nvar draw   = SVG('drawing')\nvar nested = draw.nested()\nvar group  = nested.group()\nvar rect   = group.rect(100, 100)\n\nrect.doc()           //-> returns draw\nrect.doc(SVG.Doc)    //-> returns draw\nrect.doc(SVG.Nested) //-> returns nested\nrect.doc(SVG.G)      //-> returns group\n```\n__`returns`: `element`__\n\n## Child references\n\n### first()\nTo get the first child of a parent element:\n\n```javascript\ndraw.first()\n```\n__`returns`: `element`__\n\n### last()\nTo get the last child of a parent element:\n\n```javascript\ndraw.last()\n```\n__`returns`: `element`__\n\n### children()\nAn array of all children will can be retreives with the `children` method:\n\n```javascript\ndraw.children()\n```\n__`returns`: `array`__\n\n### each()\nThe `each()` allows you to iterate over the all children of a parent element:\n\n```javascript\ndraw.each(function(i, children) {\n  this.fill({ color: '#f06' })\n})\n```\n\nDeep traversing is also possible by passing true as the second argument:\n\n```javascript\n// draw.each(block, deep)\ndraw.each(function(i, children) {\n  this.fill({ color: '#f06' })\n}, true)\n```\n\nNote that `this` refers to the current child element.\n\n__`returns`: `itself`__\n\n### has()\nChecking the existence of an element within a parent:\n\n```javascript\nvar rect  = draw.rect(100, 50)\nvar group = draw.group()\n\ndraw.has(rect)  //-> returns true\ngroup.has(rect) //-> returns false\n```\n__`returns`: `boolean`__\n\n### index()\nReturns the index of given element and returns -1 when it is not a child:\n\n```javascript\nvar rect  = draw.rect(100, 50)\nvar group = draw.group()\n\ndraw.index(rect)  //-> returns 0\ngroup.index(rect) //-> returns -1\n```\n__`returns`: `number`__\n\n### get()\nGet an element on a given position in the children array:\n\n```javascript\nvar rect   = draw.rect(20, 30)\nvar circle = draw.circle(50)\n\ndraw.get(0) //-> returns rect\ndraw.get(1) //-> returns circle\n```\n__`returns`: `element`__\n\n### clear()\nTo remove all elements from a parent element:\n\n```javascript\ndraw.clear()\n```\n__`returns`: `itself`__\n\n\n## Attribute references\n\n### reference()\nIn cases where an element is linked to another element through an attribute, the linked element instance can be fetched with the `reference()` method. The only thing required is the attribute name:\n\n```javascript\nuse.reference('href') //-> returns used element instance\n// or\nrect.reference('fill') //-> returns gradient or pattern instance for example\n// or\ncircle.reference('clip-path') //-> returns clip instance\n```\n\n## Import / export SVG\n\n### svg()\nExporting the full generated SVG, or a part of it, can be done with the `svg()` method:\n\n```javascript\ndraw.svg()\n```\n\nExporting works on all elements.\n\nImporting is done with the same method:\n\n```javascript\ndraw.svg('<g><rect width=\"100\" height=\"50\" fill=\"#f06\"></rect></g>')\n```\n\nImporting works on any element that inherits from `SVG.Parent`, which is basically every element that can contain other elements.\n\n`getter`__`returns`: `string`__\n\n`setter`__`returns`: `itself`__\n\n## Manipulating elements\n\n### attr()\nYou can get and set an element's attributes directly using `attr()`.\n\nGet a single attribute:\n```javascript\nrect.attr('x')\n```\n\nSet a single attribute:\n```javascript\nrect.attr('x', 50)\n```\n\nSet multiple attributes at once:\n```javascript\nrect.attr({\n  fill: '#f06'\n, 'fill-opacity': 0.5\n, stroke: '#000'\n, 'stroke-width': 10\n})\n```\n\nSet an attribute with a namespace:\n```javascript\nrect.attr('x', 50, 'http://www.w3.org/2000/svg')\n```\n\nExplicitly remove an attribute:\n```javascript\nrect.attr('fill', null)\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n\n### transform()\n\nThe `transform()` method acts as a full getter without an argument:\n\n```javascript\nelement.transform()\n```\n\nThe returned __`object`__ contains the following values:\n\n- `x` (translation on the x-axis)\n- `y` (translation on the y-axis)\n- `skewX` (calculated skew on x-axis)\n- `skewY` (calculated skew on y-axis)\n- `scaleX` (calculated scale on x-axis)\n- `scaleY` (calculated scale on y-axis)\n- `rotation` (calculated rotation)\n- `cx` (last used rotation centre on x-axis)\n- `cy` (last used rotation centre on y-axis)\n\nAdditionally a string value for the required property can be passed:\n\n```javascript\nelement.transform('rotation')\n```\n\nIn this case the returned value is a __`number`__.\n\n\nAs a setter it has two ways of working. By default transformations are absolute. For example, if you call:\n\n```javascript\nelement.transform({ rotation: 125 }).transform({ rotation: 37.5 })\n```\n\nThe resulting rotation will be `37.5` and not the sum of the two transformations. But if that's what you want there is a way out by adding the `relative` parameter. That would be:\n\n\n```javascript\nelement.transform({ rotation: 125 }).transform({ rotation: 37.5, relative: true })\n```\n\nAlternatively a relative flag can be passed as the second argument:\n\n```javascript\nelement.transform({ rotation: 125 }).transform({ rotation: 37.5 }, true)\n```\n\nAvailable transformations are:\n\n- `rotation` with optional `cx` and `cy`\n- `scale` with optional `cx` and `cy`\n- `scaleX` with optional `cx` and `cy`\n- `scaleY` with optional `cx` and `cy`\n- `skewX` with optional `cx` and `cy`\n- `skewY` with optional `cx` and `cy`\n- `x`\n- `y`\n- `a`, `b`, `c`, `d`, `e` and/or `f` or an existing matrix instead of the object\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### style()\nWith the `style()` method the `style` attribute can be managed like attributes with `attr`:\n\n```javascript\nrect.style('cursor', 'pointer')\n```\n\nMultiple styles can be set at once using an object:\n\n```javascript\nrect.style({ cursor: 'pointer', fill: '#f03' })\n```\n\nOr a css string:\n\n```javascript\nrect.style('cursor:pointer;fill:#f03;')\n```\n\nSimilar to `attr()` the `style()` method can also act as a getter:\n\n```javascript\nrect.style('cursor')\n// => pointer\n```\n\nOr even a full getter:\n\n```javascript\nrect.style()\n// => 'cursor:pointer;fill:#f03;'\n```\n\nExplicitly deleting individual style definitions works the same as with the `attr()` method:\n\n```javascript\nrect.style('cursor', null)\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### classes()\nFetches an array of css classes on the node:\n\n```javascript\nrect.classes()\n```\n\n`getter`__`returns`: `array`__\n\n### hasClass()\nTest the presence of a given css class:\n\n```javascript\nrect.hasClass('purple-rain')\n```\n\n`getter`__`returns`: `boolean`__\n\n### addClass()\nAdds a given css class:\n\n```javascript\nrect.addClass('pink-flower')\n```\n\n`setter`__`returns`: `itself`__\n\n### removeClass()\nRemoves a given css class:\n\n```javascript\nrect.removeClass('pink-flower')\n```\n\n`setter`__`returns`: `itself`__\n\n### toggleClass()\nToggles a given css class:\n\n```javascript\nrect.toggleClass('pink-flower')\n```\n\n`setter`__`returns`: `itself`__\n\n### move()\nMove the element to a given `x` and `y` position by its upper left corner:\n\n```javascript\nrect.move(200, 350)\n```\n\nNote that you can also use the following code to move some elements (like images and rects) around:\n\n```javascript\nrect.attr({ x: 20, y: 60 })\n``` \n\nAlthough `move()` is much more convenient because it will always use the upper left corner as the position reference, whereas with using `attr()` the `x` and `y` reference differ between element types. For example, rect uses the upper left corner with the `x` and `y` attributes, circle and ellipse use their center with the `cx` and `cy` attributes and thereby simply ignoring the `x` and `y` values you might assign.\n\n__`returns`: `itself`__\n\n### x()\nMove element only along x-axis by its upper left corner:\n\n```javascript\nrect.x(200)\n```\n\nWithout an argument the `x()` method serves as a getter as well:\n\n```javascript\nrect.x() //-> returns 200\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### y()\nMove element only along y-axis by its upper left corner:\n\n```javascript\nrect.y(350)\n```\n\nWithout an argument the `y()` method serves as a getter as well:\n\n```javascript\nrect.y() //-> returns 350\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### dmove()\nMove the element to a given `x` and `y` position relative to its current position:\n\n```javascript\nrect.dmove(10, 30)\n```\n\n__`returns`: `itself`__\n\n### dx()\nMove element only along x-axis relative to its current position:\n\n```javascript\nrect.dx(200)\n```\n\n__`returns`: `itself`__\n\n### dy()\nMove element only along y-axis relative to its current position:\n\n```javascript\nrect.dy(200)\n```\n\n__`returns`: `itself`__\n\n### center()\nThis is an extra method to move an element by its center:\n\n```javascript\nrect.center(150, 150)\n```\n\n__`returns`: `itself`__\n\n### cx()\nMove element only along x-axis by its center:\n\n```javascript\nrect.cx(200)\n```\n\nWithout an argument the `cx()` method serves as a getter as well:\n\n```javascript\nrect.cx() //-> returns 200\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### cy()\nMove element only along y-axis by its center:\n\n```javascript\nrect.cy(350)\n```\n\nWithout an argument the `cy()` method serves as a getter as well:\n\n```javascript\nrect.cy() //-> returns 350\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### size()\nSet the size of an element by a given `width` and `height`:\n\n```javascript\nrect.size(200, 300)\n```\n\nProportional resizing is also possible by leaving out `height`:\n\n```javascript\nrect.size(200)\n```\n\nOr by passing `null` as the value for `width`:\n\n```javascript\nrect.size(null, 200)\n```\n\nSame as with `move()` the size of an element could be set by using `attr()`. But because every type of element is handles its size differently the `size()` method is much more convenient.\n\nThere is one exceptions though, the `SVG.Text` only takes one argument and applies the given value to the `font-size` attribute.\n\n__`returns`: `itself`__\n\n### width()\nSet only width of an element:\n\n```javascript\nrect.width(200)\n```\n\nThis method also acts as a getter:\n\n```javascript\nrect.width() //-> returns 200\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### height()\nSet only height of an element:\n\n```javascript\nrect.height(325)\n```\n\nThis method also acts as a getter:\n\n```javascript\nrect.height() //-> returns 325\n```\n\n`getter`__`returns`: `value`__\n\n`setter`__`returns`: `itself`__\n\n### hide()\nHide element:\n\n```javascript\nrect.hide()\n```\n\n__`returns`: `itself`__\n\n### show()\nShow element:\n\n```javascript\nrect.show()\n```\n\n__`returns`: `itself`__\n\n### visible()\nTo check if the element is visible:\n\n```javascript\nrect.visible()\n```\n\n__`returns`: `boolean`__\n\n### clone()\nTo make an exact copy of an element the `clone()` method comes in handy:\n\n```javascript\nvar clone = rect.clone()\n```\n\n__`returns`: `element`__\n\nThis will create an new, unlinked copy. If you want to make a linked clone have a look at the [use](#elements/use) element.\n\n### remove()\nPretty straightforward:\n\n```javascript\nrect.remove()\n```\n\n__`returns`: `itself`__\n\n### replace()\nThis method will replace the called element with the given element in the same position in the stack:\n\n```javascript\nrect.replace(draw.circle(100))\n```\n\n__`returns`: `element`__\n\n\n## Inserting elements\n\n### add()\nElements can be moved between parents via the `add()` method on any parent:\n\n```javascript\nvar rect = draw.rect(100, 100)\nvar group = draw.group()\n\ngroup.add(rect) //-> returns group\n```\n\n__`returns`: `itself`__\n\n### put()\nWhere the `add()` method returns the parent itself, the `put()` method returns the given element:\n\n```javascript\ngroup.put(rect) //-> returns rect\n```\n\n__`returns`: `element`__\n\n### addTo()\nSimilar to the `add()` method on a parent element, elements have the `addTo()` method:\n\n```javascript\nrect.addTo(group) //-> returns rect\n```\n\n__`returns`: `itself`__\n\n### putIn()\nSimilar to the `put()` method on a parent element, elements have the `putIn()` method:\n\n```javascript\nrect.putIn(group) //-> returns group\n```\n\n__`returns`: `element`__\n\n## Geometry\n\n### viewbox()\n\nThe `viewBox` attribute of an `<svg>` element can be managed with the `viewbox()` method. When supplied with four arguments it will act as a setter:\n\n```javascript\ndraw.viewbox(0, 0, 297, 210)\n```\n\nAlternatively you can also supply an object as the first argument:\n\n```javascript\ndraw.viewbox({ x: 0, y: 0, width: 297, height: 210 })\n```\n\nWithout any arguments an instance of `SVG.ViewBox` will be returned:\n\n```javascript\nvar box = draw.viewbox()\n```\n\nBut the best thing about the `viewbox()` method is that you can get the zoom of the viewbox:\n\n```javascript\nvar box = draw.viewbox()\nvar zoom = box.zoom\n```\n\nIf the size of the viewbox equals the size of the svg drawing, the zoom value will be 1.\n\n`getter`__`returns`: `SVG.ViewBox`__\n\n`setter`__`returns`: `itself`__\n\n### bbox()\nGet the bounding box of an element. This is a wrapper for the native `getBBox()` method but adds more values:\n\n```javascript\npath.bbox()\n```\n\nThis will return an instance of `SVG.BBox` containing the following values:\n\n- `width` (value from native `getBBox`)\n- `height` (value from native `getBBox`)\n- `w` (shorthand for `width`)\n- `h` (shorthand for `height`)\n- `x` (value from native `getBBox`) \n- `y` (value from native `getBBox`)\n- `cx` (center `x` of the bounding box)\n- `cy` (center `y` of the bounding box)\n- `x2` (lower right `x` of the bounding box)\n- `y2` (lower right `y` of the bounding box)\n\nThe `SVG.BBox` has one other nifty little feature, enter the `merge()` method. With `merge()` two `SVG.BBox` instances can be merged into one new instance, basically being the bounding box of the two original bounding boxes:\n\n```javascript\nvar box1 = draw.rect(100,100).move(50,50)\nvar box2 = draw.rect(100,100).move(200,200)\nvar box3 = box1.merge(box2)\n```\n\n__`returns`: `SVG.BBox`__\n\n### tbox()\nWhere `bbox()` returns a bounding box mindless of any transformations, the `tbox()` method does take transformations into account. So any translation or scale will be applied to the resulting values to get closer to the actual visual representation:\n\n```javascript\npath.tbox()\n```\n\nThis will return an instance of `SVG.TBox` containing the following values:\n\n- `width` (value from native getBBox influenced by the `scaleX` of the current matrix)\n- `height` (value from native getBBox influenced by the `scaleY` of the current matrix)\n- `w` (shorthand for `width`)\n- `h` (shorthand for `height`)\n- `x` (value from native getBBox influenced by the `x` of the current matrix)\n- `y` (value from native getBBox influenced by the `y` of the current matrix)\n- `cx` (center `x` of the bounding box)\n- `cy` (center `y` of the bounding box)\n- `x2` (lower right `x` of the bounding box)\n- `y2` (lower right `y` of the bounding box)\n\nNote that the rotation of the element will not be added to the calculation.\n\n__`returns`: `SVG.TBox`__\n\n### rbox()\nIs similar to `bbox()` but will give you the box around the exact visual representation of the element, taking all transformations into account.\n\n```javascript\npath.rbox()\n```\n\nThis will return an instance of `SVG.RBox` containing the following values:\n\n- `width` (the actual visual width)\n- `height` (the actual visual height)\n- `w` (shorthand for `width`)\n- `h` (shorthand for `height`)\n- `x` (the actual visual position on the x-axis)\n- `y` (the actual visual position on the y-axis)\n- `cx` (center `x` of the bounding box)\n- `cy` (center `y` of the bounding box)\n- `x2` (lower right `x` of the bounding box)\n- `y2` (lower right `y` of the bounding box)\n\n__Important__: Mozilla browsers include stroke widths where other browsers do not. Therefore the resulting box might be different in Mozulla browsers. It is very hard to modify this behavior so for the time being this is an inconvenience we have to live with.\n\n__`returns`: `SVG.RBox`__\n\n### ctm()\nRetreives the current transform matrix of the element:\n\n```javascript\npath.ctm()\n```\n\n__`returns`: `SVG.Matrix`__\n\n### inside()\nTo check if a given point is inside the bounding box of an element you can use the `inside()` method:\n\n```javascript\nvar rect = draw.rect(100, 100).move(50, 50)\n\nrect.inside(25, 30) //-> returns false\nrect.inside(60, 70) //-> returns true\n```\n\nNote: the `x` and `y` positions are tested against the relative position of the element. Any offset on the parent element is not taken into account.\n\n__`returns`: `boolean`__\n\n### length()\nGet the total length of a path element:\n\n```javascript\nvar length = path.length()\n```\n\n__`returns`: `number`__\n\n### pointAt()\nGet point on a path at given length:\n\n```javascript\nvar point = path.pointAt(105) //-> returns { x : 96.88497924804688, y : 58.062747955322266 }\n```\n\n__`returns`: `object`__\n\n\n## Animating elements\n\n### Animatable method chain\nNote that the `animate()` method will not return the targeted element but an instance of SVG.FX which will take the following methods:\n\nOf course `attr()`:\n```javascript\nrect.animate().attr({ fill: '#f03' })\n```\n\nThe `x()`, `y()` and `move()` methods:\n```javascript\nrect.animate().move(100, 100)\n```\n\nAnd the `cx()`, `cy()` and `center()` methods:\n```javascript\nrect.animate().center(200, 200)\n```\n\nIf you include the sugar.js module, `fill()`, `stroke()`, `rotate()`, `skew()`, `scale()`, `matrix()`, `opacity()`, `radius()` will be available as well:\n```javascript\nrect.animate().rotate(45).skew(25, 0)\n```\n\nYou can also animate non-numeric unit values using the `attr()` method:\n```javascript\nrect.attr('x', '10%').animate().attr('x', '50%')\n```\n\n### easing\nAll available ease types are:\n\n- `<>`: ease in and out\n- `>`: ease out\n- `<`: ease in\n- `-`: linear\n- `=`: external control\n- a function\n\nFor the latter, here is an example of the default `<>` function:\n\n```javascript\nfunction(pos) { return (-Math.cos(pos * Math.PI) / 2) + 0.5 }\n```\n\nFor more easing equations, have a look at the [svg.easing.js](https://github.com/wout/svg.easing.js) plugin.\n\n### animate()\nAnimating elements is very much the same as manipulating elements, the only difference is you have to include the `animate()` method:\n\n```javascript\nrect.animate().move(150, 150)\n```\n\nThe `animate()` method will take three arguments. The first is `duration`, the second `ease` and the third `delay`:\n\n```javascript\nrect.animate(2000, '>', 1000).attr({ fill: '#f03' })\n```\n\nAlternatively you can pass an object as the first argument:\n\n```javascript\nrect.animate({ ease: '<', delay: '1.5s' }).attr({ fill: '#f03' })\n```\n\nBy default `duration` will be set to `1000`, `ease` will be set to `<>`.\n\n__`returns`: `SVG.FX`__\n\n\n### pause()\nPausing an animations is fairly straightforward:\n\n```javascript\nrect.animate().move(200, 200)\n\nrect.mouseover(function() { this.pause() })\n```\n\n__`returns`: `itself`__\n\n### play()\nWill start playing a paused animation:\n\n```javascript\nrect.animate().move(200, 200)\n\nrect.mouseover(function() { this.pause() })\nrect.mouseout(function() { this.play() })\n```\n__`returns`: `itself`__\n\n### stop()\nAnimations can be stopped in two ways.\n\nBy calling the `stop()` method:\n```javascript\nrect.animate().move(200, 200)\n\nrect.stop()\n```\n\nOr by invoking another animation:\n```javascript\nrect.animate().move(200, 200)\n\nrect.animate().center(200, 200)\n```\n\nBy calling `stop()`, the transition is left at its current position. By passing `true` as the first argument to `stop()`, the animation will be fulfilled instantly:\n\n```javascript\nrect.animate().move(200, 200)\n\nrect.stop(true)\n```\n\nStopping an animation is irreversable.\n\n__`returns`: `itself`__\n\n### during()\nIf you want to perform your own actions during the animations you can use the `during()` method:\n\n```javascript\nvar position\n  , from = 100\n  , to   = 300\n\nrect.animate(3000).move(100, 100).during(function(pos) {\n  position = from + (to - from) * pos \n})\n```\nNote that `pos` is `0` in the beginning of the animation and `1` at the end of the animation.\n\nTo make things easier a morphing function is passed as the second argument. This function accepts a `from` and `to` value as the first and second argument and they can be a number, unit or hex color:\n\n```javascript\nvar ellipse = draw.ellipse(100, 100).attr('cx', '20%').fill('#333')\n\nrect.animate(3000).move(100, 100).during(function(pos, morph) {\n  // numeric values\n  ellipse.size(morph(100, 200), morph(100, 50))\n  \n  // unit strings\n  ellipse.attr('cx', morph('20%', '80%'))\n  \n  // hex color strings\n  ellipse.fill(morph('#333', '#ff0066'))\n})\n```\n\n__`returns`: `SVG.FX`__\n\n### loop()\nBy default the `loop()` method creates and eternal loop:\n\n```javascript\nrect.animate(3000).move(100, 100).loop()\n```\n\nBut the loop can also be a predefined number of times:\n\n```javascript\nrect.animate(3000).move(100, 100).loop(3)\n```\n\nLoops go from beginning to end and start over again (`0->1.0->1.0->1.`).\n\nThere is also a reverse flag that should be passed as the second argument:\n\n```javascript\nrect.animate(3000).move(100, 100).loop(3, true)\n```\n\nLoops will then be completely reversed before starting over (`0->1->0->1->0->1.`).\n\n__`returns`: `SVG.FX`__\n\n### after()\nFinally, you can add callback methods using `after()`:\n\n```javascript\nrect.animate(3000).move(100, 100).after(function() {\n  this.animate().attr({ fill: '#f06' })\n})\n```\n\nNote that the `after()` method will never be called if the animation is looping eternally. \n\n__`returns`: `SVG.FX`__\n\n### at()\nSay you want to control the position of an animation with an external event, then the `at()` method will proove very useful:\n\n```javascript\nvar animation = draw.rect(100, 100).move(50, 50).animate('=').move(200, 200)\n\ndocument.onmousemove = function(event) {\n  animation.at(event.clientX / 1000)\n}\n```\n\nIn order to be able to use the `at()` method, the duration of the animation should be set to `'='`. The value passed as the first argument of `at()` should be a number between `0` and `1`, `0` being the beginning of the animation and `1` being the end. Note that any values below `0` and above `1` will be normalized.\n\n_This functionality requires the fx.js module which is included in the default distribution._\n\n__`returns`: `SVG.FX`__\n\n\n### situation\nThe current situation of an animation is stored in the `situation` object:\n\n```javascript\nrect.animate(3000).move(100, 100)\nrect.fx.situation //-> everything is in here\n```\n\nAvailable values are:\n\n- `start` (start time as a number in milliseconds)\n- `play` (animation playing or not; `true` or `false`)\n- `pause` (time when the animation was last paused)\n- `duration` (the chosen duration of the animation)\n- `ease` (the chosen easing calculation)\n- `finish` (start + duration)\n- `loop` (the current loop; counting down if a number; `true`, `false` or a number)\n- `loops` (if a number, the total number loops; `true`, `false` or a number)\n- `reverse` (whether or not the loop should be reversed; `true` or `false`)\n- `reversing` (`true` if the loop is currently reversing, otherwise `false`)\n- `during` (the function that should be called on every keyframe)\n- `after` (the function that should be called after completion)\n\n\n## Syntax sugar\n\nFill and stroke are used quite often. Therefore two convenience methods are provided:\n\n### fill()\nThe `fill()` method is a pretty alternative to the `attr()` method:\n\n```javascript\nrect.fill({ color: '#f06', opacity: 0.6 })\n```\n\nA single hex string will work as well:\n\n```javascript\nrect.fill('#f06')\n```\n\nLast but not least, you can also use an image as fill, simply by passing an image url:\n\n```javascript\nrect.fill('images/shade.jpg')\n```\n\nOr if you want more control over the size of the image, you can pass an image instance as well:\n\n```javascript\nrect.fill(draw.image('images/shade.jpg', 20, 20))\n```\n\n__`returns`: `itself`__\n\n### stroke()\nThe `stroke()` method is similar to `fill()`:\n\n```javascript\nrect.stroke({ color: '#f06', opacity: 0.6, width: 5 })\n```\n\nLike fill, a single hex string will work as well:\n\n```javascript\nrect.stroke('#f06')\n```\n\nNot unlike the `fill()` method, you can also use an image as stroke, simply by passing an image url:\n\n```javascript\nrect.stroke('images/shade.jpg')\n```\n\nOr if you want more control over the size of the image, you can pass an image instance as well:\n\n```javascript\nrect.stroke(draw.image('images/shade.jpg', 20, 20))\n```\n\n__`returns`: `itself`__\n\n### opacity()\nTo set the overall opacity of an element:\n\n```javascript\nrect.opacity(0.5)\n```\n\n__`returns`: `itself`__\n\n### rotate()\nThe `rotate()` method will automatically rotate elements according to the center of the element:\n\n```javascript\n// rotate(degrees)\nrect.rotate(45)\n```\n\nAlthough you can also define a specific rotation point:\n\n```javascript\n// rotate(degrees, cx, cy)\nrect.rotate(45, 50, 50)\n```\n\n__`returns`: `itself`__\n\n### skew()\nThe `skew()` method will take an `x` and `y` value:\n\n```javascript\n// skew(x, y)\nrect.skew(0, 45)\n```\n\n__`returns`: `itself`__\n\n### scale()\nThe `scale()` method will take an `x` and `y` value:\n\n```javascript\n// scale(x, y)\nrect.scale(0.5, -1)\n```\n\n__`returns`: `itself`__\n\n### translate()\nThe `translate()` method will take an `x` and `y` value:\n\n```javascript\n// translate(x, y)\nrect.translate(0.5, -1)\n```\n\n### radius()\nRects and ellipses have a `radius()` method. On rects it defines rounded corners, on ellipses the radii:\n\n```javascript\nrect.radius(10)\n```\n\nThis will set the `rx` and `ry` attributes to `10`. To set `rx` and `ry` individually:\n\n```javascript\nrect.radius(10, 20)\n```\n\n_This functionality requires the sugar.js module which is included in the default distribution._\n\n__`returns`: `itself`__\n\n\n## Masking elements\n\n### maskWith()\nThe easiest way to mask is to use a single element:\n\n```javascript\nvar ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })\n\nrect.maskWith(ellipse)\n```\n\n__`returns`: `itself`__\n\n### mask()\nBut you can also use multiple elements:\n\n```javascript\nvar ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })\nvar text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })\n\nvar mask = draw.mask().add(text).add(ellipse)\n\nrect.maskWith(mask)\n```\n\nIf you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient:\n\n```javascript\nvar gradient = draw.gradient('linear', function(stop) {\n  stop.at({ offset: 0, color: '#000' })\n  stop.at({ offset: 1, color: '#fff' })\n})\n\nvar ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })\n\nrect.maskWith(ellipse)\n```\n\n__`returns`: `SVG.Mask`__\n\n### unmask()\nUnmasking the elements can be done with the `unmask()` method:\n\n```javascript\nrect.unmask()\n```\n\nThe `unmask()` method returns the masking element.\n\n__`returns`: `itself`__\n\n### remove()\nRemoving the mask alltogether will also `unmask()` all masked elements as well:\n\n```javascript\nmask.remove()\n```\n\n__`returns`: `itself`__\n\n### masker\nFor your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask:\n\n```javascript\nrect.masker.fill('#fff')\n```\n\n_This functionality requires the mask.js module which is included in the default distribution._\n\n\n## Clipping elements\nClipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill color and clipPaths don't.\n\n### clipWith()\n```javascript\nvar ellipse = draw.ellipse(80, 40).move(10, 10)\n\nrect.clipWith(ellipse)\n```\n\n__`returns`: `itself`__\n\n### clip()\nClip multiple elements:\n\n```javascript\nvar ellipse = draw.ellipse(80, 40).move(10, 10)\nvar text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })\n\nvar clip = draw.clip().add(text).add(ellipse)\n\nrect.clipWith(clip)\n```\n\n__`returns`: `SVG.ClipPath`__\n\n### unclip()\nUnclipping the elements can be done with the `unclip()` method:\n\n```javascript\nrect.unclip()\n```\n\n__`returns`: `itself`__\n\n### remove()\nRemoving the clip alltogether will also `unclip()` all clipped elements as well:\n\n```javascript\nclip.remove()\n```\n\n__`returns`: `itself`__\n\n### clipper\nFor your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath:\n\n```javascript\nrect.clipper.move(10, 10)\n```\n\n_This functionality requires the clip.js module which is included in the default distribution._\n\n\n## Arranging elements\nYou can arrange elements within their parent SVG document using the following methods.\n\n### front()\nMove element to the front:\n\n```javascript\nrect.front()\n```\n\n__`returns`: `itself`__\n\n### back()\nMove element to the back:\n\n```javascript\nrect.back()\n```\n\n__`returns`: `itself`__\n\n### forward()\nMove element one step forward:\n\n```javascript\nrect.forward()\n```\n\n__`returns`: `itself`__\n\n### backward()\nMove element one step backward:\n\n```javascript\nrect.backward()\n```\n\n__`returns`: `itself`__\n\n### siblings()\nThe arrange.js module brings some additional methods. To get all siblings of rect, including rect itself:\n\n```javascript\nrect.siblings()\n```\n\n__`returns`: `array`__\n\n### position()\nGet the position (a number) of rect between its siblings:\n\n```javascript\nrect.position()\n```\n\n__`returns`: `number`__\n\n### next()\nGet the next sibling:\n\n```javascript\nrect.next()\n```\n\n__`returns`: `element`__\n\n### previous()\nGet the previous sibling:\n\n```javascript\nrect.previous()\n```\n\n__`returns`: `element`__\n\n### before()\nInsert an element before another:\n\n```javascript\n// inserts circle before rect\nrect.before(circle)\n```\n\n__`returns`: `itself`__\n\n### after()\nInsert an element after another:\n\n```javascript\n// inserts circle after rect\nrect.after(circle)\n```\n\n__`returns`: `itself`__\n\n_This functionality requires the arrange.js module which is included in the default distribution._\n\n\n## Sets\nSets are very useful if you want to modify or animate multiple elements at once. A set will accept all the same methods accessible on individual elements, even the ones that you add with your own plugins! Creating a set is exactly as you would expect:\n\n```javascript\n// create some elements\nvar rect = draw.rect(100,100)\nvar circle = draw.circle(100).move(100,100).fill('#f09')\n\n// create a set and add the elements\nvar set = draw.set()\nset.add(rect).add(circle)\n\n// change the fill of all elements in the set at once\nset.fill('#ff0')\n```\n\nA single element can be a member of many sets. Sets also don't have a structural representation, in fact they are just fancy array's.\n\n### add()\nAdd an element to a set:\n\n```javascript\nset.add(rect)\n```\n\nQuite a useful feature of sets is the ability to accept multiple elements at once:\n\n```javascript\nset.add(rect, circle)\n```\n\n__`returns`: `itself`__\n\n### each()\nIterating over all members in a set is the same as with svg containers:\n\n```javascript\nset.each(function(i) {\n  this.attr('id', 'shiny_new_id_' + i)\n})\n```\n\nNote that `this` refers to the current child element.\n\n__`returns`: `itself`__\n\n### has()\nDetermine if an element is member of the set:\n\n```javascript\nset.has(rect)\n```\n\n__`returns`: `boolean`__\n\n### index()\nReturns the index of a given element in the set.\n\n```javascript\nset.index(rect) //-> -1 if element is not a member\n```\n\n__`returns`: `number`__\n\n### get()\nGets the element at a given index:\n\n```javascript\nset.get(1)\n```\n\n__`returns`: `element`__\n\n### first()\nGets the first element:\n\n```javascript\nset.first()\n```\n\n__`returns`: `element`__\n\n### last()\nGets the last element:\n\n```javascript\nset.last()\n```\n\n__`returns`: `element`__\n\n### bbox()\nGet the bounding box of all elements in the set:\n\n```javascript\nset.bbox()\n```\n\n__`returns`: `SVG.BBox`__\n\n### remove()\nTo remove an element from a set:\n\n```javascript\nset.remove(rect)\n```\n\n__`returns`: `itself`__\n\n### clear()\nOr to remove all elements from a set:\n\n```javascript\nset.clear()\n```\n\n__`returns`: `itself`__\n\n### animate()\nSets work with animations as well:\n\n```javascript\nset.animate(3000).fill('#ff0')\n```\n\n__`returns`: `SVG.SetFX`__\n\n\n## Gradient\n\n### gradient()\nThere are linear and radial gradients. The linear gradient can be created like this:\n\n```javascript\nvar gradient = draw.gradient('linear', function(stop) {\n  stop.at(0, '#333')\n  stop.at(1, '#fff')\n})\n```\n\n__`returns`: `SVG.Gradient`__\n\n### at()\nThe `offset` and `color` parameters are required for stops, `opacity` is optional. Offset is float between 0 and 1, or a percentage value (e.g. `33%`). \n\n```javascript\nstop.at(0, '#333')\n```\n\nor\n\n```javascript\nstop.at({ offset: 0, color: '#333', opacity: 1 })\n```\n\n__`returns`: `itself`__\n\n### from()\nTo define the direction you can set from `x`, `y` and to `x`, `y`:\n\n```javascript\ngradient.from(0, 0).to(0, 1)\n```\n\nThe from and to values are also expressed in percent.\n\n__`returns`: `itself`__\n\n### to()\nTo define the direction you can set from `x`, `y` and to `x`, `y`:\n\n```javascript\ngradient.from(0, 0).to(0, 1)\n```\n\nThe from and to values are also expressed in percent.\n\n__`returns`: `itself`__\n\n### radius()\nRadial gradients have a `radius()` method to define the outermost radius to where the inner color should develop:\n\n```javascript\nvar gradient = draw.gradient('radial', function(stop) {\n  stop.at(0, '#333')\n  stop.at(1, '#fff')\n})\n\ngradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)\n```\n\n__`returns`: `itself`__\n\n### update()\nA gradient can also be updated afterwards:\n\n```javascript\ngradient.update(function(stop) {\n  stop.at(0.1, '#333', 0.2)\n  stop.at(0.9, '#f03', 1)\n})\n```\n\nAnd even a single stop can be updated:\n\n```javascript\nvar s1, s2, s3\n\ndraw.gradient('radial', function(stop) {\n  s1 = stop.at(0, '#000')\n  s2 = stop.at(0.5, '#f03')\n  s3 = stop.at(1, '#066')\n})\n\ns1.update(0.1, '#0f0', 1)\n```\n\n__`returns`: `itself`__\n\n### get()\nThe `get()` method makes it even easier to get a stop from an existing gradient:\n\n```javascript\nvar gradient = draw.gradient('radial', function(stop) {\n  stop.at({ offset: 0, color: '#000', opacity: 1 })   // -> first\n  stop.at({ offset: 0.5, color: '#f03', opacity: 1 }) // -> second\n  stop.at({ offset: 1, color: '#066', opacity: 1 })   // -> third\n})\n\nvar s1 = gradient.get(0) // -> returns \"first\" stop\n```\n\n__`returns`: `SVG.Stop`__\n\n### fill()\nFinally, to use the gradient on an element:\n\n```javascript\nrect.attr({ fill: gradient })\n```\n\nOr:\n\n```javascript\nrect.fill(gradient)\n```\n\nBy passing the gradient instance as the fill on any element, the `fill()` method will be called:\n\n```javascript\ngradient.fill() //-> returns 'url(#SvgjsGradient1234)'\n```\n\n[W3Schools](http://www.w3schools.com/svg/svg_grad_linear.asp) has a great example page on how\n[linear gradients](http://www.w3schools.com/svg/svg_grad_linear.asp) and\n[radial gradients](http://www.w3schools.com/svg/svg_grad_radial.asp) work.\n\n_This functionality requires the gradient.js module which is included in the default distribution._\n\n__`returns`: `value`__\n\n\n## Pattern\n\n### pattern()\nCreating a pattern is very similar to creating gradients:\n\n```javascript\nvar pattern = draw.pattern(20, 20, function(add) {\n  add.rect(20,20).fill('#f06')\n  add.rect(10,10)\n  add.rect(10,10).move(10,10)\n})\n```\n\nThis creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern.\n\n__`returns`: `SVG.Pattern`__\n\n\n### update()\nA pattern can also be updated afterwards:\n\n```javascript\npattern.update(function(add) {\n  add.circle(15).center(10,10)\n})\n```\n\n__`returns`: `itself`__\n\n\n### fill()\nFinally, to use the pattern on an element:\n\n```javascript\nrect.attr({ fill: pattern })\n```\n\nOr:\n\n```javascript\nrect.fill(pattern)\n```\n\nBy passing the pattern instance as the fill on any element, the `fill()` method will be called on th pattern instance:\n\n```javascript\npattern.fill() //-> returns 'url(#SvgjsPattern1234)'\n```\n\n__`returns`: `value`__\n\n\n## Marker\n\n### marker()\nMarkers can be added to every individual point of a `line`, `polyline`, `polygon` and `path`. There are three types of markers: `start`, `mid` and `end`. Where `start` represents the first point, `end` the last and `mid` every point in between.\n\n```javascript\nvar path = draw.path('M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100z')\n\npath.fill('none').stroke({ width: 1 })\n\npath.marker('start', 10, 10, function(add) {\n  add.circle(10).fill('#f06')\n})\npath.marker('mid', 10, 10, function(add) {\n  add.rect(10, 10)\n})\npath.marker('end', 20, 20, function(add) {\n  add.circle(6).center(4, 5)\n  add.circle(6).center(4, 15)\n  add.circle(6).center(16, 10)\n\n  this.fill('#0f6')\n})\n```\n\nThe `marker()` method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times so it will create a marker in the defs but not show it yet:\n\n```javascript\nvar marker = draw.marker(10, 10, function(add) {\n  add.rect(10, 10)\n})\n```\n\nSecondly a marker can be created and applied directly on its target element:\n\n```javascript\npath.marker('start', 10, 10, function(add) {\n  add.circle(10).fill('#f06')\n})\n```\n\nThis will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example.\n\nLastly, if a marker is created for reuse on a container element, it can be applied directly on the target element:\n\n```javascript\npath.marker('mid', marker)\n```\n\nFinally, to get a marker instance from the target element reference:\n\n```javascript\npath.reference('marker-end')\n```\n\n\n### ref()\nBy default the `refX` and `refY` attributes of a marker are set to respectively half the `width` nd `height` values. To define the `refX` and `refY` of a marker differently:\n\n```javascript\nmarker.ref(2, 7)\n```\n\n__`returns`: `itself`__\n\n### update()\nUpdating the contents of a marker will `clear()` the existing content and add the content defined in the block passed as the first argument:\n\n```javascript\nmarker.update(function(add) {\n  add.circle(10)\n})\n```\n\n__`returns`: `itself`__\n\n### width()\nDefines the `markerWidth` attribute:\n\n```javascript\nmarker.width(10)\n```\n\n__`returns`: `itself`__\n\n### height()\nDefines the `markerHeight` attribute:\n\n```javascript\nmarker.height(10)\n```\n\n__`returns`: `itself`__\n\n### size()\nDefines the `markerWidth` and `markerHeight` attributes:\n\n```javascript\nmarker.size(10, 10)\n```\n\n__`returns`: `itself`__\n\n\n## Data\n\n### Setting\nThe `data()` method allows you to bind arbitrary objects, strings and numbers to SVG elements:\n\n```javascript\nrect.data('key', { value: { data: 0.3 }})\n```\n\nOr set multiple values at once:\n\n```javascript\nrect.data({\n  forbidden: 'fruit'\n, multiple: {\n    values: 'in'\n  , an: 'object'\n  }\n})\n```\n\n__`returns`: `itself`__\n\n### Getting\nFetching the values is similar to the `attr()` method:\n\n```javascript\nrect.data('key')\n```\n\n__`returns`: `itself`__\n\n### Removing\nRemoving the data altogether:\n\n```javascript\nrect.data('key', null)\n```\n\n__`returns`: `itself`__\n\n### Sustaining data types\nYour values will always be stored as JSON and in some cases this might not be desirable. If you want to store the value as-is, just pass true as the third argument:\n\n```javascript\nrect.data('key', 'value', true)\n```\n\n__`returns`: `itself`__\n\n\n## Memory\n\n### remember() \nStoring data in-memory is very much like setting attributes:\n\n```javascript\nrect.remember('oldBBox', rect.bbox())\n```\n\nMultiple values can also be remembered at once:\n\n```javascript\nrect.remember({\n  oldFill:    rect.attr('fill')\n, oldStroke:  rect.attr('stroke')\n})\n```\n\nTo retrieve a memory\n\n```javascript\nrect.remember('oldBBox')\n```\n\n__`returns`: `itself`__\n\n### forget()\nErasing a single memory:\n\n```javascript\nrect.forget('oldBBox')\n```\n\nOr erasing multiple memories at once:\n\n\n```javascript\nrect.forget('oldFill', 'oldStroke')\n```\n\nAnd finally, just erasing the whole memory:\n\n```javascript\nrect.forget()\n```\n\n__`returns`: `itself`__\n\n## Events\n\n### Basic events\nEvents can be bound to elements as follows:\n\n```javascript\nrect.click(function() {\n  this.fill({ color: '#f06' })\n})\n```\n\nRemoving it is quite as easy:\n\n```javascript\nrect.click(null)\n```\n\nAll available events are: `click`, `dblclick`, `mousedown`, `mouseup`, `mouseover`, `mouseout`, `mousemove`, `touchstart`, `touchmove`, `touchleave`, `touchend` and `touchcancel`.\n\n__`returns`: `itself`__\n\n### Event listeners\nYou can also bind event listeners to elements:\n\n```javascript\nvar click = function() {\n  this.fill({ color: '#f06' })\n}\n\nrect.on('click', click)\n```\n\n__`returns`: `itself`__\n\nUnbinding events is just as easy:\n\n```javascript\nrect.off('click', click)\n```\n\nOr to unbind all listeners for a given event:\n\n```javascript\nrect.off('click')\n```\n\nOr even unbind all listeners for all events:\n\n```javascript\nrect.off()\n```\n\n__`returns`: `itself`__\n\nBut there is more to event listeners. You can bind events to html elements as well:\n\n```javascript\nSVG.on(window, 'click', click)\n```\n\nObviously unbinding is practically the same:\n\n```javascript\nSVG.off(window, 'click', click)\n```\n\n### Custom events\nYou can even use your own events.\n\nJust add an event listener for your event:\n```javascript\nrect.on('myevent', function() {\n  alert('ta-da!')\n})\n```\n\nNow you are ready to fire the event whenever you need:\n\n```javascript\nfunction whenSomethingHappens() {\n  rect.fire('myevent') \n}\n\n// or if you want to pass an event\nfunction whenSomethingHappens(event) {\n  rect.fire(event) \n}\n\n```\n\nYou can also pass some data to the event:\n\n```javascript\nfunction whenSomethingHappens() {\n  rect.fire('myevent', {some:'data'}) \n}\n\nrect.on('myevent', function(e) {\n  alert(e.detail.some) // outputs 'data'\n})\n```\n\nsvg.js supports namespaced events following the syntax `event.namespace`.\n\nA namespaced event behaves like a normal event with the difference that you can remove it without touching handlers from other namespaces.\n\n```\n// attach\nrect.on('myevent.namespace', function(e) {\n  // do something\n})\n\n// detach all handlers of namespace for myevent\nrect.off('myevent.namespace')\n\n// detach all handlers of namespace\nrect.off('.namespace')\n\n// detach all handlers including all namespaces\nrect.off('myevent)\n```\n\nHowever you can't fire a specific namespaced event. Calling `rect.fire('myevent.namespace')` won't do anything while `rect.fire('myevent')` works and fires all attached handlers of the event\n\n_Important: always make sure you namespace your event to avoid conflicts. Preferably use something very specific. So `event.wicked` for example would be better than something generic like `event.svg`._\n\n## Numbers\n\nNumbers in SVG.js have a dedicated number class to be able to process string values. Creating a new number is simple:\n\n```javascript\nvar number = new SVG.Number('78%')\nnumber.plus('3%').toString() //-> returns '81%'\nnumber.valueOf() //-> returns 0.81\n```\n\nOperators are defined as methods on the `SVG.Number` instance.\n\n### plus()\nAddition:\n\n```javascript\nnumber.plus('3%')\n```\n\n__`returns`: `SVG.Number`__\n\n### minus()\nSubtraction:\n\n```javascript\nnumber.minus('3%')\n```\n\n__`returns`: `SVG.Number`__\n\n### times()\nMultiplication:\n\n```javascript\nnumber.times(2)\n```\n\n__`returns`: `SVG.Number`__\n\n### divide()\nDivision:\n\n```javascript\nnumber.divide('3%')\n```\n\n__`returns`: `SVG.Number`__\n\n### to()\nChange number to another unit:\n\n```javascript\nnumber.to('px')\n```\n\n__`returns`: `SVG.Number`__\n\n### morph()\nMake a number morphable:\n\n```javascript\nnumber.morph('11%')\n```\n\n__`returns`: `itself`__\n\n\n### at()\nGet morphable number at given position:\n\n```javascript\nvar number = new SVG.Number('79%').morph('3%')\nnumber.at(0.55).toString() //-> '37.2%'\n```\n\n__`returns`: `SVG.Number`__\n\n\n## Colors\n\nSvg.js has a dedicated color class handling different types of colors. Accepted values are:\n\n- hex string; three based (e.g. #f06) or six based (e.g. #ff0066) `new SVG.Color('#f06')`\n- rgb string; e.g. rgb(255, 0, 102) `new SVG.Color('rgb(255, 0, 102)')`\n- rgb object; e.g. { r: 255, g: 0, b: 102 } `new SVG.Color({ r: 255, g: 0, b: 102 })`\n\nNote that when working with objects is important to provide all three values every time.\n\nThe `SVG.Color` instance has a few methods of its own.\n\n### toHex()\nGet hex value:\n\n```javascript\ncolor.toHex() //-> returns '#ff0066'\n```\n\n__`returns`: hex color string__\n\n### toRgb()\nGet rgb string value:\n\n```javascript\ncolor.toRgb() //-> returns 'rgb(255,0,102)'\n```\n\n__`returns`: rgb color string__\n\n### brightness()\nGet the brightness of a color:\n\n```javascript\ncolor.brightness() //-> returns 0.344\n```\n\nThis is the perceived brighness where `0` is black and `1` is white.\n\n__`returns`: `number`__\n\n### morph()\nMake a color morphable:\n\n```javascript\ncolor.morph('#000')\n```\n\n__`returns`: `itself`__\n\n### at()\nGet morphable color at given position:\n\n```javascript\nvar color = new SVG.Color('#ff0066').morph('#000')\ncolor.at(0.5).toHex() //-> '#7f0033'\n```\n\n__`returns`: `SVG.Color`__\n\n\n## Arrays\nIn SVG.js every value list string can be cast and passed as an array. This makes writing them more convenient but also adds a lot of key functionality to them.\n\n### SVG.Array\nIs for simple, whitespace separated value strings:\n\n```javascript\n'0.343 0.669 0.119 0 0 0.249 -0.626 0.13 0 0 0.172 0.334 0.111 0 0 0 0 0 1 0'\n```\n\nCan also be passed like this in a more manageable format:\n\n```javascript\nnew SVG.Array([ .343,  .669, .119, 0,   0 \n              , .249, -.626, .130, 0,   0\n              , .172,  .334, .111, 0,   0\n              , .000,  .000, .000, 1,  -0 ])\n```\n\n### SVG.PointArray \nIs a bit more complex and is used for polyline and polygon elements. This is a poly-point string:\n\n```javascript\n'0,0 100,100'\n```\n\nThe dynamic representation:\n\n```javascript\n[\n  [0, 0]\n, [100, 100]\n]\n```\n\nPrecompiling it as an `SVG.PointArray`:\n\n```javascript\nnew SVG.PointArray([\n  [0, 0]\n, [100, 100]\n])\n```\n\nNote that every instance of `SVG.Polyline` and `SVG.Polygon` carries a reference to the `SVG.PointArray` instance:\n\n```javascript\npolygon.array() //-> returns the SVG.PointArray instance\n```\n\n_Javascript inheritance stack: `SVG.PointArray` < `SVG.Array`_\n\n### SVG.PathArray\nPath arrays carry arrays representing every segment in a path string:\n\n```javascript\n'M0 0L100 100z'\n```\n\nThe dynamic representation:\n\n```javascript\n[\n  ['M', 0, 0]\n, ['L', 100, 100]\n, ['z']\n]\n```\n\nPrecompiling it as an `SVG.PathArray`:\n\n```javascript\nnew SVG.PathArray([\n  ['M', 0, 0]\n, ['L', 100, 100]\n, ['z']\n])\n```\n\nNote that every instance of `SVG.Path` carries a reference to the `SVG.PathArray` instance:\n\n```javascript\npath.array() //-> returns the SVG.PathArray instance\n```\n\n#### Syntax\nThe syntax for patharrays is very predictable. They are basically literal representations in the form of two dimentional arrays.\n\n##### Move To\nOriginal syntax is `M0 0` or `m0 0`. The SVG.js syntax `['M',0,0]` or `['m',0,0]`.\n\n##### Line To\nOriginal syntax is `L100 100` or `l100 100`. The SVG.js syntax `['L',100,100]` or `['l',100,100]`.\n\n##### Horizontal line\nOriginal syntax is `H200` or `h200`. The SVG.js syntax `['H',200]` or `['h',200]`.\n\n##### Vertical line\nOriginal syntax is `V300` or `v300`. The SVG.js syntax `['V',300]` or `['v',300]`.\n\n##### Bezier curve\nOriginal syntax is `C20 20 40 20 50 10` or `c20 20 40 20 50 10`. The SVG.js syntax `['C',20,20,40,20,50,10]` or `['c',20,20,40,20,50,10]`.\n\nOr mirrored with `S`:\n\nOriginal syntax is `S40 20 50 10` or `s40 20 50 10`. The SVG.js syntax `['S',40,20,50,10]` or `['s',40,20,50,10]`.\n\nOr quadratic with `Q`:\n\nOriginal syntax is `Q20 20 50 10` or `q20 20 50 10`. The SVG.js syntax `['Q',20,20,50,10]` or `['q',20,20,50,10]`.\n\nOr a complete shortcut with `T`:\n\nOriginal syntax is `T50 10` or `t50 10`. The SVG.js syntax `['T',50,10]` or `['t',50,10]`.\n\n##### Arc\nOriginal syntax is `A 30 50 0 0 1 162 163` or `a 30 50 0 0 1 162 163`. The SVG.js syntax `['A',30,50,0,0,1,162,163]` or `['a',30,50,0,0,1,162,163]`.\n\n##### Close\nOriginal syntax is `Z` or `z`. The SVG.js syntax `['Z']` or `['z']`.\n\nThe best documentation on paths can be found at https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths.\n\n\n_Javascript inheritance stack: `SVG.PathArray` < `SVG.Array`_\n\n### morph()\nIn order to animate array values the `morph()` method lets you pass a destination value. This can be either the string value, a plain array or an instance of the same type of SVG.js array:\n\n```javascript\nvar array = new SVG.PointArray([[0, 0], [100, 100]])\narray.morph('100,0 0,100 200,200')\n```\n\nThis method will prepare the array ensuring both the source and destination arrays have the same length.\n\nNote that this method is currently not available on `SVG.PathArray` but will be soon.\n\n__`returns`: `itself`__\n\n### at()\nThis method will morph the array to a given position between `0` and `1`. Continuing with the previous example:\n\n```javascript\narray.at(0.27).toString() //-> returns '27,0 73,100 127,127'\n```\n\nNote that this method is currently not available on `SVG.PathArray` but will be soon.\n\n__`returns`: new instance__\n\n### settle()\nWhen morphing is done the `settle()` method will eliminate any transitional points like duplicates:\n\n```javascript\narray.settle()\n```\n\nNote that this method is currently not available on `SVG.PathArray` but will be soon.\n\n__`returns`: `itself`__\n\n### move()\nMoves geometry of the array with the given `x` and `y` values:\n\n```javascript\nvar array = new SVG.PointArray([[0, 0], [100, 100]])\narray.move(33,75)\narray.toString() //-> returns '33,75 133,175'\n```\n\nNote that this method is only available on `SVG.PointArray` and `SVG.PathArray`\n\n__`returns`: `itself`__\n\n### size()\nResizes geometry of the array by the given `width` and `height` values:\n\n```javascript\nvar array = new SVG.PointArray([[0, 0], [100, 100]])\narray.move(100,100).size(222,333)\narray.toString() //-> returns '100,100 322,433'\n```\n\nNote that this method is only available on `SVG.PointArray` and `SVG.PathArray`\n\n__`returns`: `itself`__\n\n### reverse()\nReverses the order of the array:\n\n```javascript\nvar array = new SVG.PointArray([[0, 0], [100, 100]])\narray.reverse()\narray.toString() //-> returns '100,100 0,0'\n```\n\n__`returns`: `itself`__\n\n### bbox()\nGets the bounding box of the geometry of the array:\n\n```javascript\narray.bbox()\n```\n\nNote that this method is only available on `SVG.PointArray` and `SVG.PathArray`\n\n__`returns`: `object`__\n\n\n## Matrices\nMatrices in SVG.js have their own class `SVG.Matrix`, wrapping the native `SVGMatrix`. They add a lot of functionality like extracting transform values, matrix morphing and improvements on the native methods.\n\n### SVG.Matrix\nIn SVG.js matrices accept various values on initialization.\n\nWithout a value:\n\n```javascript\nvar matrix = new SVG.Matrix\nmatrix.toString() //-> returns matrix(1,0,0,1,0,0)\n```\n\nSix arguments:\n\n```javascript\nvar matrix = new SVG.Matrix(1, 0, 0, 1, 100, 150)\nmatrix.toString() //-> returns matrix(1,0,0,1,100,150)\n```\n\nA string value:\n\n```javascript\nvar matrix = new SVG.Matrix('1,0,0,1,100,150')\nmatrix.toString() //-> returns matrix(1,0,0,1,100,150)\n```\n\nAn object value:\n\n```javascript\nvar matrix = new SVG.Matrix({ a: 1, b: 0, c: 0, d: 1, e: 100, f: 150 })\nmatrix.toString() //-> returns matrix(1,0,0,1,100,150)\n```\n\nA native `SVGMatrix`:\n\n```javascript\nvar svgMatrix = svgElement.getCTM()\nvar matrix = new SVG.Matrix(svgMatrix)\nmatrix.toString() //-> returns matrix(1,0,0,1,0,0)\n```\n\nEven an instance of `SVG.Element`:\n\n```javascript\nvar rect = draw.rect(50, 25)\nvar matrix = new SVG.Matrix(rect)\nmatrix.toString() //-> returns matrix(1,0,0,1,0,0)\n```\n\n### extract()\nGets the calculated values of the matrix as an object:\n\n```javascript\nmatrix.extract()\n```\n\nThe returned object contains the following values:\n\n- `x` (translation on the x-axis)\n- `y` (translation on the y-axis)\n- `skewX` (calculated skew on x-axis)\n- `skewY` (calculated skew on y-axis)\n- `scaleX` (calculated scale on x-axis)\n- `scaleY` (calculated scale on y-axis)\n- `rotation` (calculated rotation)\n\n__`returns`: `object`__\n\n### clone()\nReturns an exact copy of the matrix:\n\n```javascript\nmatrix.clone()\n```\n\n__`returns`: `SVG.Matrix`__\n\n### morph()\nIn order to animate matrices the `morph()` method lets you pass a destination matrix. This can be any value a `SVG.Matrix` would accept on initialization:\n\n```javascript\nmatrix.morph('matrix(2,0,0,2,100,150)')\n```\n\n__`returns`: `itself`__\n\n### at()\nThis method will morph the matrix to a given position between `0` and `1`:\n\n```javascript\nmatrix.at(0.27)\n```\n\nThis will only work when a destination matirx is defined using the `morph()` method.\n\n__`returns`: `SVG.Matrix`__\n\n### multiply()\nMultiplies by another given matrix:\n\n```javascript\nmatrix.matrix(matrix2)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### inverse()\nCreates an inverted matix:\n\n```javascript\nmatrix.inverse()\n```\n\n__`returns`: `SVG.Matrix`__\n\n### translate()\nTranslates matrix by a given x and y value:\n\n```javascript\nmatrix.translate(10, 20)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### scale()\nScales matrix uniformal with one value:\n\n```javascript\n// scale\nmatrix.scale(2)\n```\n\nScales matrix non-uniformal with two values:\n\n```javascript\n// scaleX, scaleY\nmatrix.scale(2, 3)\n```\n\nScales matrix uniformal on a given center point with three values:\n\n```javascript\n// scale, cx, cy\nmatrix.scale(2, 100, 150)\n```\n\nScales matrix non-uniformal on a given center point with four values:\n\n```javascript\n// scaleX, scaleY, cx, cy\nmatrix.scale(2, 3, 100, 150)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### rotate()\nRotates matrix by degrees with one value given:\n\n```javascript\n// degrees\nmatrix.rotate(45)\n```\n\nRotates a matrix by degrees around a given point with three values:\n\n```javascript\n// degrees, cx, cy\nmatrix.rotate(45, 100, 150)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### flip()\nFlips matrix over a given axis:\n\n```javascript\nmatrix.flip('x')\n```\n\nor\n\n```javascript\nmatrix.flip('y')\n```\n\nBy default elements are flipped over their center point. The flip axis position can be defined with the second argument:\n\n```javascript\nmatrix.flip('x', 150)\n```\n\nor\n\n```javascript\nmatrix.flip('y', 100)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### skew()\nSkews matrix a given degrees over x and or y axis with two values:\n\n```javascript\n// degreesX, degreesY\nmatrix.skew(0, 45)\n```\n\nSkews matrix a given degrees over x and or y axis on a given point with four values:\n\n```javascript\n// degreesX, degreesY, cx, cy\nmatrix.skew(0, 45, 150, 100)\n```\n\n__`returns`: `SVG.Matrix`__\n\n### around()\nPerforms a given matrix transformation around a given center point:\n\n```javascript\n// cx, cy, matrix\nmatrix.around(100, 150, new SVG.Matrix().skew(0, 45))\n```\n\nThe matrix passed as the third argument will be used to multiply.\n\n__`returns`: `SVG.Matrix`__\n\n### native()\nReturns a native `SVGMatrix` extracted from the `SVG.Matrix` instance:\n\n```javascript\nmatrix.native()\n```\n\n__`returns`: `SVGMatrix`__\n\n### toString()\nConverts the matrix to a transform string:\n\n```javascript\nmatrix.toString()\n// -> matrix(1,0,0,1,0,0)\n```\n\n__`returns`: `string`__\n\n## Extending functionality\n\n### SVG.invent()\nCreating your own custom elements with SVG.js is a piece of cake thanks to the `SVG.invent` function. For the sake of this example, lets \"invent\" a shape. We want a `rect` with rounded corners that are always proportional to the height of the element. The new shape lives in the `SVG` namespace and is called `Rounded`. Here is how we achieve that.\n\n```javascript\nSVG.Rounded = SVG.invent({\n  // Define the type of element that should be created\n  create: 'rect'\n\n  // Specify from which existing class this shape inherits\n, inherit: SVG.Shape\n\n  // Add custom methods to invented shape\n, extend: {\n    // Create method to proportionally scale the rounded corners\n    size: function(width, height) {\n      return this.attr({\n        width:  width\n      , height: height\n      , rx:     height / 5\n      , ry:     height / 5\n      })\n    }\n  }\n\n  // Add method to parent elements\n, construct: {\n    // Create a rounded element\n    rounded: function(width, height) {\n      return this.put(new SVG.Rounded).size(width, height)\n    }\n    \n  }\n})\n```\n\nTo create the element in your drawing:\n\n```javascript\nvar rounded = draw.rounded(200, 100)\n```\n\nThat's it, the invention is now ready to be used!\n\n#### Accepted values\nThe `SVG.invent()` function always expects an object. The object can have the following configuration values:\n\n- `create`: can be either a string with the node name (e.g. `rect`, `ellipse`, ...) or a custom initializer function; `[required]`\n- `inherit`: the desired SVG.js class to inherit from (e.g. `SVG.Shape`, `SVG.Element`, `SVG.Container`, `SVG.Rect`, ...); `[optional but recommended]`\n- `extend`: an object with the methods that should be applied to the element's prototype; `[optional]`\n- `construct`: an object with the methods to create the element on the parent element; `[optional]`\n- `parent`: an SVG.js parent class on which the methods in the passed `construct` object should be available; `[optional]`\n\nSvg.js uses the `SVG.invent()` function to create all internal elements, so have a look at the source to see how this function is used in various ways.\n\n\n### SVG.extend()\nSVG.js has a modular structure. It is very easy to add you own methods at different levels. Let's say we want to add a method to all shape types then we would add our method to SVG.Shape:\n\n```javascript\nSVG.extend(SVG.Shape, {\n  paintRed: function() {\n    return this.fill('red')\n  }\n})\n```\n\nNow all shapes will have the paintRed method available. Say we want to have the paintRed method on an ellipse apply a slightly different color:\n\n```javascript\nSVG.extend(SVG.Ellipse, {\n  paintRed: function() {\n    return this.fill('orangered')\n  }\n})\n\n```\nThe complete inheritance stack for `SVG.Ellipse` is:\n\n_`SVG.Ellipse` < `SVG.Shape` < `SVG.Element`_\n\nThe SVG document can be extended by using:\n\n```javascript\nSVG.extend(SVG.Doc, {\n  paintAllPink: function() {\n    this.each(function() {\n      this.fill('pink')\n    })\n  }\n})\n```\n\nYou can also extend multiple elements at once:\n```javascript\nSVG.extend(SVG.Ellipse, SVG.Path, SVG.Polygon, {\n  paintRed: function() {\n    return this.fill('orangered')\n  }\n})\n```\n\n\n## Plugins\nHere are a few nice plugins that are available for SVG.js:\n\n** Caution: Not tested for SVG.js 2.0 **\n\n### absorb\n[svg.absorb.js](https://github.com/wout/svg.absorb.js) absorb raw SVG data into an SVG.js instance.\n\n### draggable\n[svg.draggable.js](https://github.com/wout/svg.draggable.js) to make elements draggable.\n\n### connectable\n[svg.connectable.js](https://github.com/jillix/svg.connectable.js) to connect elements.\n\n[svg.connectable.js fork](https://github.com/loredanacirstea/svg.connectable.js) to connect elements (added: curved connectors, you can use any self-made path as a connector, choosable 'center'/'perifery' attachment, 'perifery' attachment for source / target SVG Paths uses smallest-distance algorithm between PathArray points)\n\n### easing\n[svg.easing.js](https://github.com/wout/svg.easing.js) for more easing methods on animations.\n\n### export\n[svg.export.js](https://github.com/wout/svg.export.js) export raw SVG.\n\n### filter\n[svg.filter.js](https://github.com/wout/svg.filter.js) adding svg filters to elements.\n\n### foreignobject\n[svg.foreignobject.js](https://github.com/john-memloom/svg.foreignobject.js) foreignObject implementation (by john-memloom).\n\n### import\n[svg.import.js](https://github.com/wout/svg.import.js) import raw SVG data.\n\n### math\n[svg.math.js](https://github.com/otm/svg.math.js) a math extension (by Nils Lagerkvist).\n\n### path\n[svg.path.js](https://github.com/otm/svg.path.js) for manually drawing paths (by Nils Lagerkvist).\n\n### shapes\n[svg.shapes.js](https://github.com/wout/svg.shapes.js) for more polygon based shapes.\n\n### topath\n[svg.topath.js](https://github.com/wout/svg.topath.js) to convert any other shape to a path.\n\n### topoly\n[svg.topoly.js](https://github.com/wout/svg.topoly.js) to convert a path to polygon or polyline.\n\n### wiml\n[svg.wiml.js](https://github.com/wout/svg.wiml.js) a templating language for svg output.\n\n### comic\n[comic.js](https://github.com/balint42/comic.js) to cartoonize any given svg.\n\n### draw\n[svg.draw.js](https://github.com/fuzzyma/svg.draw.js) to draw elements with your mouse\n\n### select\n[svg.select.js](https://github.com/fuzzyma/svg.select.js) to select elements\n\n### resize\n[svg.resize.js](https://github.com/fuzzyma/svg.resize.js) to resize elements with your mouse\n\n## Contributing\nWe love contributions. Yes indeed, we used the word LOVE! But please make sure you follow the same coding style. Here are some guidelines.\n\n### Indentation\nWe do it with __two spaces__. Make sure you don't start using tabs because then things get messy.\n\n### Avoid hairy code\nWe like to keep things simple and clean, don't write anything you don't need. So use __single quotes__ where possible and __avoid semicolons__, we're not writing PHP here.\n\n__Good__:\n```javascript\nvar text = draw.text('with single quotes here')\n  , nest = draw.nested().attr('x', '50%')\n\nfor (var i = 0; i < 5; i++)\n  if (i != 3)\n    nest.circle(i * 100)\n```\n\n__Bad__:\n```javascript\nvar text = draw.text(\"with single quotes here\");\nvar nest = draw.nested().attr(\"x\", \"50%\");\n\nfor (var i = 0; i < 5; i++) {\n  if (i != 3) {\n    nest.circle(100);\n  };\n};\n```\n\n### Minimize variable declarations\nAll local variables should be declared at the beginning of a function or method unless there is ony one variable to declare. Although it is not required to assign them at the same moment. When if statements are involved, requiring some variables only to be present in the statement, the necessary variables should be declared right after the if statement.\n\n__Good__:\n```javascript\nfunction reading_board() {\n  var aap, noot, mies\n\n  aap  = 1\n  noot = 2\n  mies = aap + noot\n}\n```\n\n__Bad__:\n```javascript\nfunction reading_board() {\n  var aap  = 1\n  var noot = 2\n  var mies = aap + noot\n}\n```\n\n### Let your code breathe people!\nDon't try to be a code compressor yourself, they do way a better job anyway. Give your code some spaces and newlines.\n\n__Good__:\n```javascript\nvar nest = draw.nested().attr({\n  x:      10\n, y:      20\n, width:  200\n, height: 300\n})\n\nfor (var i = 0; i < 5; i++)\n  nest.circle(100)\n```\n\n__Bad__:\n```javascript\nvar nest=draw.nested().attr({x:10,y:20,width:200,height:300});\nfor(var i=0;i<5;i++)nest.circle(100);\n```\n\n### It won't hurt to add a few comments\nWhere necessary tell us what you are doing but be concise. We only use single-line comments. Also keep your variable and method names short while maintaining readability.\n\n__Good__:\n```javascript\n// Adds orange-specific methods\nSVG.extend(SVG.Rect, {\n  // Add a nice, transparent orange\n  orangify: function() {\n    // fill with orange color\n    this.fill('orange')\n\n    // add a slight opacity\n    return this.opacity(0.85)\n  }\n})\n```\n\n__Bad__:\n```javascript\n/*\n *\n * does something with orange and opacity\n *\n */\nSVG.extend(SVG.Rect, {\n  orgf: function() {\n    return this.fill('orange').opacity(0.85)\n  }\n})\n```\n\n### Refactor your code\nOnce your implementation is ready, revisit and rework it. We like to keep it [DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself).\n\n### Test. Your. Code.\nIt's not that hard to write at least one example per implementation, although we prefer more. Your code might seem to work by quickly testing it in your brwoser but more than often you can't forsee everything.\n\nBefore running the specs you will need to build the library. Be aware that pull requests without specs will be declined.\n\n\n## Building\nAfter contributing you probably want to build the library to run some specs. Make sure you have Node.js installed on your system, `cd` to the svg.js directory and run:\n\n``` sh\n$ npm install\n```\n\nBuild SVG.js by running `gulp`:\n\n``` sh\n$ gulp\n```\n\nThe resulting files are:\n\n1. `dist/svg.js`\n2. `dist/svg.min.js`\n\n\n## Compatibility\n\n### Desktop\n- Firefox 3+\n- Chrome 4+\n- Safari 3.2+\n- Opera 9+\n- IE9+\n\n### Mobile\n- iOS Safari 3.2+\n- Android Browser 3+\n- Opera Mobile 10+\n- Chrome for Android 18+\n- Firefox for Android 15+\n\nVisit the [SVG.js test page](http://svgjs.com/test) if you want to check compatibility with different browsers.\n\n## Acknowledgements & Thanks\n\nDocumentation kindly provided by [DocumentUp](http://documentup.com)\n\nSVG.js and its documentation is released under the terms of the MIT license.\n",
  "readmeFilename": "README.md",
  "_id": "svg.js@2.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/wout/svg.js.git"
  }
}